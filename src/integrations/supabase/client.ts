
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import QRCode from 'qrcode';
import CryptoJS from 'crypto-js';

const SUPABASE_URL = "https://sxigocnatqgqgiedrgue.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4aWdvY25hdHFncWdpZWRyZ3VlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNTY1ODgsImV4cCI6MjA2MDgzMjU4OH0.JaRFyEuVOC9VXoPFc7ohO77F1qM_NwY_jOgNcSacfp4";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// تحويل Base32 إلى بايتات
function base32ToBytes(base32: string): Uint8Array {
  const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  let bits = 0;
  let value = 0;
  let index = 0;
  const result = new Uint8Array(Math.ceil(base32.length * 5 / 8));
  
  for (let i = 0; i < base32.length; i++) {
    const c = base32.charAt(i).toUpperCase();
    const charIndex = base32Chars.indexOf(c);
    if (charIndex === -1) continue;
    
    value = (value << 5) | charIndex;
    bits += 5;
    
    if (bits >= 8) {
      result[index++] = (value >> (bits - 8)) & 0xff;
      bits -= 8;
    }
  }
  
  return result;
}

// تحويل Hex إلى بايتات
function hexToBytes(hex: string): Uint8Array {
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    result[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return result;
}

// تنفيذ مخصص لـ TOTP
function generateTOTP(secret: string, windowOffset = 0): string {
  try {
    // تحويل السر من Base32 إلى بايتات
    const secretBytes = base32ToBytes(secret);
    const secretHex = Array.from(secretBytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    
    // الحصول على الوقت الحالي بالثواني وتقسيمه على 30 (مدة صلاحية الرمز)
    const epoch = Math.floor(Date.now() / 1000);
    const timeStep = 30;
    let counter = Math.floor(epoch / timeStep) + windowOffset;
    
    // تحويل العداد إلى بايتات
    const counterBytes = new Uint8Array(8);
    for (let i = 7; i >= 0; i--) {
      counterBytes[i] = counter & 0xff;
      counter = counter >> 8;
    }
    
    // تحويل counterBytes إلى hex string
    const counterHex = Array.from(counterBytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    
    // حساب HMAC-SHA1
    const hmac = CryptoJS.HmacSHA1(
      CryptoJS.enc.Hex.parse(counterHex),
      CryptoJS.enc.Hex.parse(secretHex)
    );
    
    // تحويل HMAC إلى بايتات
    const hmacHex = hmac.toString(CryptoJS.enc.Hex);
    const hmacBytes = hexToBytes(hmacHex);
    
    // حساب الإزاحة
    const offset = hmacBytes[hmacBytes.length - 1] & 0xf;
    
    // حساب الرمز
    const binary =
      ((hmacBytes[offset] & 0x7f) << 24) |
      ((hmacBytes[offset + 1] & 0xff) << 16) |
      ((hmacBytes[offset + 2] & 0xff) << 8) |
      (hmacBytes[offset + 3] & 0xff);
    
    // تحويل الرمز إلى 6 أرقام
    const otp = binary % 1000000;
    return otp.toString().padStart(6, '0');
  } catch (error) {
    console.error('Error generating TOTP:', error);
    return '000000';
  }
}

// التحقق من رمز TOTP
function verifyTOTP(token: string, secret: string, window = 1): boolean {
  try {
    // تنظيف الرمز
    const cleanToken = token.replace(/\s+/g, '');
    
    // التحقق من الرمز في نافذة زمنية
    for (let i = -window; i <= window; i++) {
      const generatedToken = generateTOTP(secret, i);
      console.log(`Generated token with window ${i}:`, generatedToken);
      if (cleanToken === generatedToken) {
        return true;
      }
    }
    
    return false;
  } catch (error) {
    console.error('Error verifying TOTP:', error);
    return false;
  }
}

// توليد سر جديد
function generateBase32Secret(length = 20) {
  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; // Base32
  const bytes = new Uint8Array(length);
  if (typeof window !== 'undefined' && window.crypto) {
    window.crypto.getRandomValues(bytes);
  } else {
    for (let i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
  }

  return Array.from(bytes)
    .map(b => charset[b % charset.length])
    .join('');
}

// توليد URI لتطبيقات المصادقة
function generateOTPAuthURI(account: string, issuer: string, secret: string): string {
  const encodedIssuer = encodeURIComponent(issuer);
  const encodedAccount = encodeURIComponent(account);
  return `otpauth://totp/${encodedIssuer}:${encodedAccount}?secret=${secret}&issuer=${encodedIssuer}`;
}

/**
 * Creates a user record in the users table
 * @param userId The ID of the user from Supabase Auth
 * @param userData Additional user data to be stored
 */
export async function createUserRecord(userId: string, userData: {
  Name?: string;
  Email: string;
  Password: string;
  Phone?: string;
  Country?: string;
  Activate?: string;
  Block?: string;
  Credits?: string;
  User_Type?: string;
  Email_Type?: string;
  Expiry_Time?: string;
  Start_Date?: string;
  Hwid?: string;
  UID?: string;
}) {
  // Map the old field names to the new Supabase schema
  const { error } = await supabase
    .from('users')
    .insert({
      id: userId,
      uid: userData.UID || userId,
      name: userData.Name || '',
      email: userData.Email,
      password: userData.Password, // Note: In production, passwords should be handled by Supabase Auth, not stored in the users table
      phone: userData.Phone || null,
      country: userData.Country || null,
      activate: userData.Activate || 'Active',
      block: userData.Block || 'Not Blocked',
      credits: userData.Credits || '0.0',
      user_type: userData.User_Type || 'Monthly License',
      email_type: userData.Email_Type || 'User',
      expiry_time: userData.Expiry_Time || null,
      start_date: userData.Start_Date || new Date().toISOString(),
      hwid: userData.Hwid || 'Null'
    });

  if (error) {
    console.error('Error creating user record:', error);
    throw new Error(`Failed to create user record: ${error.message}`);
  }

  return userId;
}

/**
 * Fetches user information by user ID
 * @param userId The ID of the user
 * @returns User data or null if not found
 */
export async function getUserInfo(userId: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', userId)
    .single();
  
  if (error) {
    console.error('Error fetching user info:', error);
    return null;
  }
  
  return data;
}

/**
 * Generate a new 2FA secret for a user
 * @param userId The user ID
 * @param email The user's email
 * @returns The secret and QR code data URL
 */
export async function generate2FASecret(userId: string, email: string) {
  try {
    // 1. توليد سر متوافق مع المتصفح
    const secret = generateBase32Secret();

    // 2. توليد URI بصيغة TOTP
    const otpauth = generateOTPAuthURI(email, 'MyApp', secret);

    // 3. توليد QR Code من URI
    const qrCodeDataUrl = await QRCode.toDataURL(otpauth);

    // 4. حفظ السر في قاعدة البيانات
    const { error } = await supabase
      .from('users')
      .update({ otp_secret: secret })
      .eq('id', userId);

    if (error) {
      console.error('Error saving OTP secret:', error);
      throw new Error('Failed to save secret');
    }

    return {
      success: true,
      secret,
      qrCodeDataUrl
    };
  } catch (err) {
    console.error('Error generating 2FA secret:', err);
    throw err;
  }
}

/**
 * Verifies a 2FA code and enables 2FA if valid
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the verification was successful
 */
export async function verify2FAToken(userId: string, token: string) {
  try {
    console.log("Verifying 2FA token for user:", userId);
    console.log("Token received:", token);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      throw new Error(`Failed to fetch 2FA secret: ${fetchError.message}`);
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      throw new Error('No OTP secret found for user');
    }
    
    console.log("Found OTP secret:", userData.otp_secret);
    
    // Verify the token using our custom implementation
    const isValid = verifyTOTP(token, userData.otp_secret);
    
    console.log("Token verification result:", isValid);
    
    if (isValid) {
      // If valid, enable 2FA for the user
      const { error: updateError } = await supabase
        .from('users')
        .update({ two_factor_enabled: true })
        .eq('id', userId);
      
      if (updateError) {
        console.error('Error enabling 2FA:', updateError);
        throw new Error(`Failed to enable 2FA: ${updateError.message}`);
      }
    }
    
    return isValid;
  } catch (error) {
    console.error('Error verifying 2FA token:', error);
    return false;
  }
}

/**
 * Validates a 2FA token during login
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the token is valid
 */
export async function validate2FAToken(userId: string, token: string) {
  try {
    console.log("Validating 2FA token for user:", userId);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      return false;
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      return false;
    }
    
    // Verify the token using our custom implementation
    return verifyTOTP(token, userData.otp_secret);
  } catch (error) {
    console.error('Error validating 2FA token:', error);
    return false;
  }
}

/**
 * Saves a QR code file for a user
 * @param userId The user ID
 * @param qrCodeDataUrl The QR code data URL to save
 * @param filename The filename to save the QR code as
 * @returns The URL of the saved file
 */
export async function saveQRCodeFile(userId: string, qrCodeDataUrl: string, filename: string = '2fa-qrcode.png') {
  try {
    // Convert data URL to Blob
    const res = await fetch(qrCodeDataUrl);
    const blob = await res.blob();
    
    // Create a file from the blob
    const file = new File([blob], filename, { type: 'image/png' });
    
    // Upload the file to storage
    const filePath = `private/${userId}/${filename}`;
    const { error: uploadError, data: uploadData } = await supabase.storage
      .from('user-files')
      .upload(filePath, file, {
        upsert: true
      });
    
    if (uploadError) {
      console.error('Error uploading QR code:', uploadError);
      throw new Error('Failed to save QR code file');
    }
    
    // Get a public URL for the file
    const { data: { publicUrl } } = supabase.storage
      .from('user-files')
      .getPublicUrl(filePath);
    
    return {
      success: true,
      url: publicUrl,
      path: filePath
    };
  } catch (error) {
    console.error('Error saving QR code file:', error);
    throw new Error('Failed to save QR code file');
  }
}

/**
 * Disable 2FA for a user
 * @param userId The user ID
 * @returns Whether disabling was successful
 */
export async function disable2FA(userId: string) {
  try {
    // Update user to disable 2FA and clear secret
    const { error } = await supabase
      .from('users')
      .update({ 
        two_factor_enabled: false,
        otp_secret: null
      })
      .eq('id', userId);
    
    if (error) {
      console.error('Error disabling 2FA:', error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error disabling 2FA:', error);
    return false;
  }
}
