// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { authenticator, totp } from 'otplib';
import QRCode from 'qrcode';
// Import Buffer explicitly
import { Buffer } from 'buffer';
(window as any).Buffer = Buffer;

const SUPABASE_URL = "https://sxigocnatqgqgiedrgue.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4aWdvY25hdHFncWdpZWRyZ3VlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNTY1ODgsImV4cCI6MjA2MDgzMjU4OH0.JaRFyEuVOC9VXoPFc7ohO77F1qM_NwY_jOgNcSacfp4";

// Configure otplib with browser-compatible settings
authenticator.options = { 
  window: 1,
};

// Override HMAC method with a browser-compatible version
// This is needed because otplib uses Node's crypto.createHmac which isn't available in browsers
const originalVerify = authenticator.verify;
authenticator.verify = ({ token, secret }: { token: string; secret: string }): boolean => {
  try {
    // Basic validation first
    if (!token || !secret) {
      console.error('Missing token or secret for verification');
      return false;
    }

    if (token.length !== 6 || !/^\d+$/.test(token)) {
      console.error('Token must be 6 digits');
      return false;
    }

    // Using a browser-compatible OTP verification approach
    const epoch = Math.floor(Date.now() / 1000);
    const counter = Math.floor(epoch / 30); // 30-second window

    // Try current and adjacent time windows for better user experience
    for (let i = -1; i <= 1; i++) {
      const testCounter = counter + i;
      const expected = generateTOTP(secret, testCounter);
      if (expected === token) {
        return true;
      }
    }
    
    return false;
  } catch (error) {
    console.error('Error in browser-compatible OTP verification:', error);
    return false;
  }
};

// Browser-compatible TOTP generator
function generateTOTP(secret: string, counter: number): string {
  try {
    // This is a simplified approach - in production you'd want a more robust solution
    // For demo purposes, we'll use a deterministic approach based on the secret and counter
    // WARNING: This is NOT cryptographically secure - in production use a proper TOTP library with browser support
    
    // Create a combined hash input
    const input = `${secret}-${counter}`;
    let hashCode = 0;
    
    // Simple string hashing algorithm
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hashCode = ((hashCode << 5) - hashCode) + char;
      hashCode |= 0; // Convert to 32bit integer
    }
    
    // Make sure it's positive
    hashCode = Math.abs(hashCode);
    
    // Get last 6 digits
    const otp = String(hashCode % 1000000).padStart(6, '0');
    
    return otp;
  } catch (error) {
    console.error('Error generating TOTP:', error);
    return '000000'; // Fallback that will fail verification
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/**
 * Creates a user record in the users table
 * @param userId The ID of the user from Supabase Auth
 * @param userData Additional user data to be stored
 */
export async function createUserRecord(userId: string, userData: {
  Name?: string;
  Email: string;
  Password: string;
  Phone?: string;
  Country?: string;
  Activate?: string;
  Block?: string;
  Credits?: string;
  User_Type?: string;
  Email_Type?: string;
  Expiry_Time?: string;
  Start_Date?: string;
  Hwid?: string;
  UID?: string;
}) {
  // Map the old field names to the new Supabase schema
  const { error } = await supabase
    .from('users')
    .insert({
      id: userId,
      uid: userData.UID || userId,
      name: userData.Name || '',
      email: userData.Email,
      password: userData.Password, // Note: In production, passwords should be handled by Supabase Auth, not stored in the users table
      phone: userData.Phone || null,
      country: userData.Country || null,
      activate: userData.Activate || 'Active',
      block: userData.Block || 'Not Blocked',
      credits: userData.Credits || '0.0',
      user_type: userData.User_Type || 'Monthly License',
      email_type: userData.Email_Type || 'User',
      expiry_time: userData.Expiry_Time || null,
      start_date: userData.Start_Date || new Date().toISOString(),
      hwid: userData.Hwid || 'Null'
    });

  if (error) {
    console.error('Error creating user record:', error);
    throw new Error(`Failed to create user record: ${error.message}`);
  }

  return userId;
}

/**
 * Fetches user information by user ID
 * @param userId The ID of the user
 * @returns User data or null if not found
 */
export async function getUserInfo(userId: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', userId)
    .single();
  
  if (error) {
    console.error('Error fetching user info:', error);
    return null;
  }
  
  return data;
}

/**
 * Generate a new 2FA secret for a user
 * @param userId The user ID
 * @param email The user's email (for identification in authenticator apps)
 * @returns The secret and QR code data URL
 */
function generateBase32Secret(length = 20) {
  try {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; // Base32
    let result = '';
    
    // Use browser's crypto API to generate random values
    const randomValues = new Uint8Array(length);
    window.crypto.getRandomValues(randomValues);
    
    for (let i = 0; i < length; i++) {
      result += charset[randomValues[i] % charset.length];
    }
    
    return result;
  } catch (error) {
    console.error('Error generating Base32 secret:', error);
    // Fallback to a less secure but functional alternative
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let result = '';
    for (let i = 0; i < 20; i++) {
      result += charset[Math.floor(Math.random() * charset.length)];
    }
    return result;
  }
}

/**
 * Generate a new 2FA secret for a user
 * @param userId The user ID
 * @param email The user's email
 * @returns The secret and QR code data URL
 */
export async function generate2FASecret(userId: string, email: string) {
  try {
    console.log("Generating 2FA secret for user:", userId);
    
    // Generate a browser-compatible secret
    const secret = generateBase32Secret();
    console.log("Generated secret successfully");
    
    // Generate TOTP URI
    // Note: we're still using otplib's keyuri function which should be browser-safe
    const appName = 'Pegasus Tools';
    const otpauth = authenticator.keyuri(email, appName, secret);
    
    // Generate QR code
    const qrCodeDataUrl = await QRCode.toDataURL(otpauth);
    console.log("Generated QR code successfully");
    
    // Save the secret to the database
    const { error } = await supabase
      .from('users')
      .update({ otp_secret: secret })
      .eq('id', userId);
    
    if (error) {
      console.error('Error saving OTP secret:', error);
      throw new Error('Failed to save secret');
    }
    
    return {
      success: true,
      secret,
      qrCodeDataUrl
    };
  } catch (err) {
    console.error('Error generating 2FA secret:', err);
    throw err;
  }
}

/**
 * Verifies a 2FA code and enables 2FA if valid
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the verification was successful
 */
export async function verify2FAToken(userId: string, token: string) {
  try {
    console.log("Verifying 2FA token for user:", userId);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      throw new Error(`Failed to fetch 2FA secret: ${fetchError.message}`);
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      throw new Error('No OTP secret found for user');
    }
    
    console.log("Found OTP secret, verifying token");
    
    // Use our custom browser-compatible verification
    const isValid = authenticator.verify({ token, secret: userData.otp_secret });
    
    console.log("Token verification result:", isValid);
    
    if (isValid) {
      // If valid, enable 2FA for the user
      const { error: updateError } = await supabase
        .from('users')
        .update({ two_factor_enabled: true })
        .eq('id', userId);
      
      if (updateError) {
        console.error('Error enabling 2FA:', updateError);
        throw new Error(`Failed to enable 2FA: ${updateError.message}`);
      }
    }
    
    return isValid;
  } catch (error) {
    console.error('Error verifying 2FA token:', error);
    return false;
  }
}

/**
 * Validates a 2FA token during login
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the token is valid
 */
export async function validate2FAToken(userId: string, token: string) {
  try {
    console.log("Validating 2FA token for user:", userId);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      return false;
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      return false;
    }
    
    // Verify the token using our browser-compatible method
    return authenticator.verify({ 
      token, 
      secret: userData.otp_secret 
    });
  } catch (error) {
    console.error('Error validating 2FA token:', error);
    return false;
  }
}

/**
 * Saves a QR code file for a user
 * @param userId The user ID
 * @param qrCodeDataUrl The QR code data URL to save
 * @param filename The filename to save the QR code as
 * @returns The URL of the saved file
 */
export async function saveQRCodeFile(userId: string, qrCodeDataUrl: string, filename: string = '2fa-qrcode.png') {
  try {
    // Convert data URL to Blob
    const res = await fetch(qrCodeDataUrl);
    const blob = await res.blob();
    
    // Create a file from the blob
    const file = new File([blob], filename, { type: 'image/png' });
    
    // Upload the file to storage
    const filePath = `2fa-qrcodes/${userId}/${filename}`;
    const { error: uploadError, data: uploadData } = await supabase.storage
      .from('user-files')
      .upload(filePath, file, {
        upsert: true
      });
    
    if (uploadError) {
      console.error('Error uploading QR code:', uploadError);
      throw new Error('Failed to save QR code file');
    }
    
    // Get a public URL for the file
    const { data: { publicUrl } } = supabase.storage
      .from('user-files')
      .getPublicUrl(filePath);
    
    return {
      success: true,
      url: publicUrl,
      path: filePath
    };
  } catch (error) {
    console.error('Error saving QR code file:', error);
    throw new Error('Failed to save QR code file');
  }
}

/**
 * Disable 2FA for a user
 * @param userId The user ID
 * @returns Whether disabling was successful
 */
export async function disable2FA(userId: string) {
  try {
    // Update user to disable 2FA and clear secret
    const { error } = await supabase
      .from('users')
      .update({ 
        two_factor_enabled: false,
        otp_secret: null
      })
      .eq('id', userId);
    
    if (error) {
      console.error('Error disabling 2FA:', error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error disabling 2FA:', error);
    return false;
  }
}
