
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { authenticator, totp } from 'otplib';
import QRCode from 'qrcode';
// Import Buffer explicitly
import { Buffer } from 'buffer';
(window as any).Buffer = Buffer;

const SUPABASE_URL = "https://sxigocnatqgqgiedrgue.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4aWdvY25hdHFncWdpZWRyZ3VlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNTY1ODgsImV4cCI6MjA2MDgzMjU4OH0.JaRFyEuVOC9VXoPFc7ohO77F1qM_NwY_jOgNcSacfp4";

// Configure otplib with browser-compatible settings
authenticator.options = { 
  window: 1,
  // Use a custom crypto implementation that works in browsers
  crypto: {
    randomBytes: (size) => {
      const array = new Uint8Array(size);
      if (typeof window !== 'undefined' && window.crypto) {
        window.crypto.getRandomValues(array);
      } else {
        // Fallback for non-browser environments
        for (let i = 0; i < size; i++) {
          array[i] = Math.floor(Math.random() * 256);
        }
      }
      return Buffer.from(array);
    }
  }
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/**
 * Creates a user record in the users table
 * @param userId The ID of the user from Supabase Auth
 * @param userData Additional user data to be stored
 */
export async function createUserRecord(userId: string, userData: {
  Name?: string;
  Email: string;
  Password: string;
  Phone?: string;
  Country?: string;
  Activate?: string;
  Block?: string;
  Credits?: string;
  User_Type?: string;
  Email_Type?: string;
  Expiry_Time?: string;
  Start_Date?: string;
  Hwid?: string;
  UID?: string;
}) {
  // Map the old field names to the new Supabase schema
  const { error } = await supabase
    .from('users')
    .insert({
      id: userId,
      uid: userData.UID || userId,
      name: userData.Name || '',
      email: userData.Email,
      password: userData.Password, // Note: In production, passwords should be handled by Supabase Auth, not stored in the users table
      phone: userData.Phone || null,
      country: userData.Country || null,
      activate: userData.Activate || 'Active',
      block: userData.Block || 'Not Blocked',
      credits: userData.Credits || '0.0',
      user_type: userData.User_Type || 'Monthly License',
      email_type: userData.Email_Type || 'User',
      expiry_time: userData.Expiry_Time || null,
      start_date: userData.Start_Date || new Date().toISOString(),
      hwid: userData.Hwid || 'Null'
    });

  if (error) {
    console.error('Error creating user record:', error);
    throw new Error(`Failed to create user record: ${error.message}`);
  }

  return userId;
}

/**
 * Fetches user information by user ID
 * @param userId The ID of the user
 * @returns User data or null if not found
 */
export async function getUserInfo(userId: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', userId)
    .single();
  
  if (error) {
    console.error('Error fetching user info:', error);
    return null;
  }
  
  return data;
}

/**
 * Generate a new 2FA secret for a user
 * @param userId The user ID
 * @param email The user's email (for identification in authenticator apps)
 * @returns The secret and QR code data URL
 */
function generateBase32Secret(length = 20) {
  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; // Base32
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);

  return Array.from(bytes)
    .map(b => charset[b % charset.length])
    .join('');
}

/**
 * Generate a new 2FA secret for a user
 * @param userId The user ID
 * @param email The user's email
 * @returns The secret and QR code data URL
 */
export async function generate2FASecret(userId: string, email: string) {
  try {
    // 1. توليد سر متوافق مع المتصفح
    const secret = generateBase32Secret();

    // 2. توليد URI بصيغة TOTP
    const otpauth = authenticator.keyuri(email, 'MyApp', secret);

    // 3. توليد QR Code من URI
    const qrCodeDataUrl = await QRCode.toDataURL(otpauth);

    // 4. حفظ السر في قاعدة البيانات
    const { error } = await supabase
      .from('users')
      .update({ otp_secret: secret })
      .eq('id', userId);

    if (error) {
      console.error('Error saving OTP secret:', error);
      throw new Error('Failed to save secret');
    }

    return {
      success: true,
      secret,
      qrCodeDataUrl
    };
  } catch (err) {
    console.error('Error generating 2FA secret:', err);
    throw err;
  }
}

/**
 * Verifies a 2FA code and enables 2FA if valid
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the verification was successful
 */

// Utility functions for TOTP verification without relying on otplib's internal crypto
function base32Decode(encoded: string): Uint8Array {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  let bits = '';
  const paddingChar = '=';
  encoded = encoded.replace(paddingChar, '').toUpperCase();

  for (let i = 0; i < encoded.length; i++) {
    const charIndex = alphabet.indexOf(encoded[i]);
    if (charIndex === -1) throw new Error(`Invalid character in base32: ${encoded[i]}`);
    bits += charIndex.toString(2).padStart(5, '0');
  }

  const bytes = [];
  for (let i = 0; i < bits.length; i += 8) {
    const byteStr = bits.substring(i, i + 8);
    if (byteStr.length < 8) break;
    bytes.push(parseInt(byteStr, 2));
  }

  return new Uint8Array(bytes);
}

async function verifyTOTP(token: string, secret: string): Promise<boolean> {
  const key = base32Decode(secret);
  const timeStep = 30;
  const window = 1;
  const epoch = Math.floor(Date.now() / 1000);
  const counter = Math.floor(epoch / timeStep);

  for (let i = -window; i <= window; i++) {
    const currentCounter = counter + i;
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setUint32(4, currentCounter, false); // Big-endian by default

    const cryptoKey = await window.crypto.subtle.importKey(
      "raw",
      key.buffer,
      { name: "HMAC", hash: "SHA-1" },
      false,
      ["sign"]
    );

    const signature = await window.crypto.subtle.sign("HMAC", cryptoKey, buffer);
    const sigBytes = new Uint8Array(signature);
    const code = truncate(sigBytes);

    if (code === parseInt(token, 10)) {
      return true;
    }
  }

  return false;
}

function truncate(hmac: Uint8Array): number {
  const offset = hmac[hmac.length - 1] & 0xf;
  return (
    ((hmac[offset] & 0x7f) << 24 |
      (hmac[offset + 1] << 16) |
      (hmac[offset + 2] << 8) |
      hmac[offset + 3]) %
    1_000_000
  );
}

export async function verify2FAToken(userId: string, token: string) {
  try {
    console.log("Verifying 2FA token for user:", userId);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      throw new Error(`Failed to fetch 2FA secret: ${fetchError.message}`);
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      throw new Error('No OTP secret found for user');
    }
    
    console.log("Found OTP secret, verifying token");
    
    // Use our custom TOTP verification instead of otplib's built-in one
    const isValid = await verifyTOTP(token, userData.otp_secret);
    
    console.log("Token verification result:", isValid);
    
    if (isValid) {
      // If valid, enable 2FA for the user
      const { error: updateError } = await supabase
        .from('users')
        .update({ two_factor_enabled: true })
        .eq('id', userId);
      
      if (updateError) {
        console.error('Error enabling 2FA:', updateError);
        throw new Error(`Failed to enable 2FA: ${updateError.message}`);
      }
    }
    
    return isValid;
  } catch (error) {
    console.error('Error verifying 2FA token:', error);
    return false;
  }
}

/**
 * Validates a 2FA token during login
 * @param userId The user ID
 * @param token The token entered by the user
 * @returns Whether the token is valid
 */
export async function validate2FAToken(userId: string, token: string) {
  try {
    console.log("Validating 2FA token for user:", userId);
    
    // Get the user's secret from the database
    const { data: userData, error: fetchError } = await supabase
      .from('users')
      .select('otp_secret')
      .eq('id', userId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('Error fetching user 2FA secret:', fetchError);
      return false;
    }
    
    if (!userData?.otp_secret) {
      console.error('No OTP secret found for user');
      return false;
    }
    
    // Verify the token
    return authenticator.verify({ 
      token, 
      secret: userData.otp_secret 
    });
  } catch (error) {
    console.error('Error validating 2FA token:', error);
    return false;
  }
}

/**
 * Saves a QR code file for a user
 * @param userId The user ID
 * @param qrCodeDataUrl The QR code data URL to save
 * @param filename The filename to save the QR code as
 * @returns The URL of the saved file
 */
export async function saveQRCodeFile(userId: string, qrCodeDataUrl: string, filename: string = '2fa-qrcode.png') {
  try {
    // Convert data URL to Blob
    const res = await fetch(qrCodeDataUrl);
    const blob = await res.blob();
    
    // Create a file from the blob
    const file = new File([blob], filename, { type: 'image/png' });
    
    // Upload the file to storage
    const filePath = `2fa-qrcodes/${userId}/${filename}`;
    const { error: uploadError, data: uploadData } = await supabase.storage
      .from('user-files')
      .upload(filePath, file, {
        upsert: true
      });
    
    if (uploadError) {
      console.error('Error uploading QR code:', uploadError);
      throw new Error('Failed to save QR code file');
    }
    
    // Get a public URL for the file
    const { data: { publicUrl } } = supabase.storage
      .from('user-files')
      .getPublicUrl(filePath);
    
    return {
      success: true,
      url: publicUrl,
      path: filePath
    };
  } catch (error) {
    console.error('Error saving QR code file:', error);
    throw new Error('Failed to save QR code file');
  }
}

/**
 * Disable 2FA for a user
 * @param userId The user ID
 * @returns Whether disabling was successful
 */
export async function disable2FA(userId: string) {
  try {
    // Update user to disable 2FA and clear secret
    const { error } = await supabase
      .from('users')
      .update({ 
        two_factor_enabled: false,
        otp_secret: null
      })
      .eq('id', userId);
    
    if (error) {
      console.error('Error disabling 2FA:', error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error disabling 2FA:', error);
    return false;
  }
}
